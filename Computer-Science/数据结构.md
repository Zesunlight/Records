## Balanced Search Tree 二叉搜索树

平衡查找树有很多不同的实现方式：

- AVL 树
- 2-3查找树
- 伸展树
- 红黑树
- B树（也写成B-树，B-tree，中间的“-”代表杠）
- B+ 树

### AVL 树

- 即平衡二叉树（Balanced Binary Tree），AVL是提出这种数据结构的数学家。概念是对于所有结点，BF 的绝对值小于等于1，即左、右子树的高度之差的绝对值小于等于1
- AVL 树在实际中并没有太多的用途，可支持 O(log n) 的查找、插入、删除，它比红黑树严格意义上更为平衡，从而导致插入和删除更慢，但遍历却更快。
- 适合用于只需要构建一次，就可以在不重新构造的情况下读取的情况。

### 2-3查找树

- 2-3查找树是一颗BST，它的结点既可以是一个2-结点，即含有两个子结点的结点（和普通二叉树一样），也可以是一个3-结点，即自身有两个value，并且含有三个子结点。
- 3-结点的左链接指向的树中的值都小于该结点的值，中链接指向的树中的值介于该结点的两个值之间，右链接指向的树的值都大于该结点的值。
- 一棵完美平衡的2-3树中的所有空结点到根结点的距离是相同的。

[![2-3 BST](https://github.com/wolverinn/Iridescent/raw/master/_v_images/20200201153506732_18806.png)](https://github.com/wolverinn/Iridescent/blob/master/_v_images/20200201153506732_18806.png)

- 为了保持平衡性，对2-3查找树的插入操作需要分为很多种情况进行调整。

### 红黑树

红黑树首先是一个二叉搜索树，同时必须要满足以下四个性质：

- Every node is colored red or black. 每个结点要么是红色，要么是黑色
- All leaf (nil) nodes are colored black. 所有的叶结点都是黑色
- Every red node has black children. 红色结点的子结点必须是黑色
- From any node, the number of black nodes on any paths to leaves is the same. 对任何一个结点来说，从这个结点到叶结点的任何路径，所经过的黑色结点的数量应该是相同的

（第二条注意一下，定义中所说的叶结点指的是所有为 **None** 的结点。当我们画一棵正常的二叉树的时候，通常都不会将这些None结点画出来）

------

- 红黑树（Red-Black Tree）是一种平衡查找树的实现方式，就像AVL树也是平衡查找树的一种实现方式一样，但是AVL树对于平衡的要求更加严格，导致插入/删除的时候更慢。
- 红黑树的定义使得它能保持一定的平衡性（不像AVL那么严格的平衡），同时又能有一定的灵活性（flexibility）。

- 红黑树的最大高度是 2log(n)，根到叶子的最长路径不会超过最短路径的2倍

- 如果把一个红黑树中的所有结点都涂成黑色，这棵树仍然是一棵红黑树，但是退化成了一棵完美平衡的二叉树。

- 在红黑树中搜索元素和BST是一样的。但是，当进行插入/删除操作的时候，红黑树的性质会被改变，这时，需要通过**变色以及旋转**的方式来使其恢复红黑树的性质。
- **左旋**（left rotation）和**右旋**（right rotation）。旋转操作之后，二叉搜索树BST的性质仍然不变。旋转的时间复杂度是常数时间。

## B树

B树英文是 **B-Tree**，所以中文的B树或者B-树都是同一个东西。至于其中的字母B，则不代表任何东西，既不是 Binary，也不是 Balance.

### B树的定义

B树是一种多路搜索树，对于一个 **m-阶** 的B树：

- Every node has at most *m* children. 每个结点最多有m个子结点
- Every non-leaf node (except root) has at least ⌈*m*/2⌉ child nodes. 每个结点（除了根结点）最少有⌈*m*/2⌉个子结点
- The root has at least two children if it is not a leaf node. 根结点至少有两个子结点（除非根结点就是叶结点）
- A non-leaf node with *k* children contains *k* − 1 keys. 如果一个结点有 k 个子结点，说明它含有 k - 1 个 key.
- All leaves appear in the same level and carry no information. 所有的叶结点都处在同一层并且不携带任何信息（其实就是None）

[![B-tree order-5](https://github.com/wolverinn/Iridescent/raw/master/_v_images/20191215105932908_17164.jpg)](https://github.com/wolverinn/Iridescent/blob/master/_v_images/20191215105932908_17164.jpg)

- B树比起平衡搜索树更加矮胖，这样做大大减小了树的高度，在B树中插入时，B树的高度也会增长得很缓慢，因为每一层都可以容纳很多元素。

- 一个结点中存放的数据结构为：(n，a0，K1，a1，K2，…，Kn，an)，其中 n 代表这个结点含有的 key 的个数，Ki 代表存放的key（也就是二叉树中的value，比如2，23，57...），按升序排列，ai 则是指向子结点的指针，并且 ai 指向的子结点中存放的 key 值总是大于 ai 左边的 key 小于 ai 右边的 key（注意是开区间）。比如a1指向的子结点中存放的元素一定介于K1和K2之间。

### B树的查找和插入

B树的查找类似于二叉搜索树的查找，在每个结点，找到待查找元素在哪个范围之间，再进入对应的子结点继续比较

插入元素的时候，先找到元素应该插入的位置，此时：

如果该结点存放的元素数量还没有超过最大限制，那么直接将该元素插入该结点

如果该结点已经满了，那就将其分裂（Split）为两个结点：

- 首先从该结点存放的所有元素以及待插入元素中选出一个中位数；
- 把小于中位数的元素放在分裂出来的左结点，大于中位数的元素放在右结点；
- 这个中位数则插入该结点的父结点。如果父结点已满，继续往上分裂；如果没有父结点，则创造一个新的父结点（会增加树的高度）

### B+ 树

![B+ Tree(m=3)](https://github.com/wolverinn/Iridescent/raw/master/_v_images/20191215153515581_13031.png)

B+ 树是 B 树的变种。广泛用于各种文件系统和数据库引擎中。B+ 树的定义与B树基本相同，不同的地方在于：

- 如果一个结点有k个key，那它有k个子结点
- 子结点中的数据**大于等于**左边的key小于右边的key
- 叶结点以指针进行连接，以链表（有序）的形式存放了所有的数据，也包含中间结点的key（因此，B+树的搜索总是会到达叶结点，中间结点不保存数据，只是用来索引的）

#### 数据库索引

- 索引是存在于索引文件中，是存在于磁盘中的。因为索引通常是很大的，因此无法一次将全部索引加载到内存当中，因此每次只能从磁盘中读取一个磁盘页的数据到内存
- B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。
- B树必须用中序遍历的方法遍历数据，而B+树直接从叶子结点挨个扫一遍就完了，在数据库中基于范围的查询是非常频繁的，B+树非常方便进行range-query，B树针对范围查询效率更低
- 卫星数据是指索引元素所指向的数据记录，比如数据库中的某一行。B树的每个节点都有卫星数据，B+树只有叶子节点有卫星数据，所以同样大小的磁盘页可以容纳更多的节点，IO查询次数更少。
- 在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。
- 